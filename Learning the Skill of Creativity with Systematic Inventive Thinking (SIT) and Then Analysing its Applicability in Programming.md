#innovation 
#creativity 
#web-development 
#programming

## Learning the Skill of Creativity with Systematic Inventive Thinking (SIT) and Then Analysing its Applicability in Programming

My understanding of SIT comes from reading the book “Inside the Box: A Proven System of Creativity for Breakthrough Results”.

Better and quicker innovation happens when we work within what we know. This is referred to as the “Closed World” principle of SIT. After all, our options should be constrained to focus our attention if this results in good solutions to problems. This does not mean that we should not think outside the box, but that we should give due emphasis to thinking within the box when we problem solve.

Inventive solutions share patterns that can become templates to direct our creative thinking to solve problems. As such, function follows form, where we start with an abstract conceptual solution and try to apply it to resolve the problem. This is the second principle of SIT. When these patterns become habits, it takes less effort to innovate because we are responding to familiar information and situations.

There are 5 creativity templates in the innovation method Systematic Inventive Thinking (SIT):
* subtraction
* division
* multiplication
* task unification
* attribute dependency

Subtraction involves the removal or diminishing of an essential feature or component of a product, service or design (PSD) to focus on its other features or components. The functional loss of this action may have to be replaced, thus overcoming functional fixedness (see below). To get the most impact from this technique, the feature or component removed or diminished should neither be the most or least essential. This technique is not about taking out bad components to improve performance, but to change the chracteristics of a product and the way it works. It is also not about downgrading the product to sell it at a lower price.

Division separates a component from a PSD to create a new PSD, or to divide it into multiple parts for rearranging to get a new benefit or existing benefit delivered in a new way. Division can be done functionally or physically, and the parts can be rearranged in space or time, thus overcoming both functional and structural fixedness. Preserving division can also be applied to create multiple smaller copies of the PSD.

Multiplication creates additional copies of a component or feature in a PSD, and changes the attributes of these copies, so that the final PSD is enhanced. Due to the changes made to the copies, the outcome of this technique is original, rather than just a duplicate.

Task unification unifies certain features or components that were previously not thought to be unifiable, into one PSD, such that it can be used for different tasks. It is also applied when the internal resources for completing tasks, usually people, are used to do different tasks to create the PSD, or when an ecosystem is created centred around the PSD. It is about getting the PSD to perform tasks it was not originally meant to do.

Attribute dependency refers to an attribute of a feature of a PSD changing in response to an event or a change in the context, such that it resolves the problems arising from the event or change in context. There is dependency only when things are variable and can change, and the possibilities should be laid out in a spreadsheet forecasting table. The dependencies should also be only between variables we can control. A dependency between originally unrelated variables may be created to solve the problem.

The process of SIT starts with a breakdown of the PSD into its components or features. This breakdown may require zooming in or out to consider and breakdown more or less of each part. For task unification, both internal and external components are to be considered. For attribute dependency, the components should be variables, and the dependencies should be mapped out in a spreadsheet.

An important aspect of applying the changes from these solution templates is to consider the benefits on stakeholders due to a change. Then, the “Closed World” possible solutions to the problems arising from the change should be considered. Finally, the value and feasibility of the end PSD should be considered.

We should not be blinded by functional fixedness (a tendency to see or use objects only in the traditional way) or structural fixedness (a tendency to see items as whole complete units in the traditional form). It must be noted that 2 or more SIT techniques can lead to a similar innovative idea. When using the techniques, we should not anticipate a logical or practical outcome. We should create the solutions based on faith that the problems that these solutions resolve can be found. Thus, the feasibility of the invented solution should always be checked at the end of the SIT process. If feasibility is lacking, the invention may have to evolve further. Making the invention user-friendly is another key concern.

A common phenomenon we face in life situations are contradictions, when a choice becomes difficult to make and there are seemingly no solutions to the problem. When this happens, we have to determine if it is a False Contradiction by considering the implicit or hidden assumptions and analyse the associations between these assumptions to discover weak links, which can be creatively overcome by applying SIT. In doing so, our hidden assumptions become erroneous. An assumption may be logical in many situations, but may not be so for our current problematic situation.

Applying SIT techniques to coding is straightforward. Taking the Vue web development framework as an example, the concept of multiplication can be seen in the basic file structure, which generally require multiple copies of .vue and .js files, each uniquely coded based on predefined structures. Divisions are applied in the technique of mixins, where similar code used in 2 or more different functions are separated and stored in a separate file, and slots, where a part of a template in a file is extracted and stored in a separate file, specifically for styling behaviours.

Subtraction can easily be applied to test code by selectively removing an essential function or section of code. Workaround code will have to be developed to overcome the removal of these essential parts. Task unification is used when the resulting Vue single page application is able to display multiple webpages, each possessing different features. Because Vue is built on JavaScript, which is a programming language, it is therefore heavily attribute dependent. This is seen in the responses to webpage events that we program for, or in various parts of the code linking 2 or more sets of data with a functional relationship.


